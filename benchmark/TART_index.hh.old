#pragma once
#include "config.h"
#include "compiler.hh"

#include "Sto.hh"

#include "string.hh"
#include "TART.hh"
#include <type_traits>

#include <vector>
#include "VersionSelector.hh"

namespace bench {
template <typename K, typename V, typename DBParams>
class tart_index : public TObject {
public:
    typedef K key_type;
    typedef V value_type;

    //typedef typename get_occ_version<DBParams>::type occ_version_type;
    typedef typename get_version<DBParams>::type version_type;

    static constexpr typename version_type::type invalid_bit = TransactionTid::user_bit;
    static constexpr TransItem::flags_type insert_bit = TransItem::user0_bit;
    static constexpr TransItem::flags_type delete_bit = TransItem::user0_bit << 1u;
    static constexpr TransItem::flags_type row_update_bit = TransItem::user0_bit << 2u;
    static constexpr TransItem::flags_type row_cell_bit = TransItem::user0_bit << 3u;
    static constexpr uintptr_t internode_bit = 1;

    typedef typename value_type::NamedColumn NamedColumn;
    typedef IndexValueContainer<V, version_type> value_container_type;

    static constexpr bool value_is_small = is_small<V>::value;

    static constexpr bool index_read_my_write = DBParams::RdMyWr;

    struct internal_elem {
        key_type key;
        value_container_type row_container;
        bool deleted;

        internal_elem(const key_type& k, const value_type& v, bool valid)
            : key(k),
              row_container((valid ? Sto::initialized_tid() : (Sto::initialized_tid() | invalid_bit)),
                            !valid, v),
              deleted(false) {}

        version_type& version() {
            return row_container.row_version();
        }

        bool valid() {
            return !(version().value() & invalid_bit);
        }
    };

    struct column_access_t {
        int col_id;
        bool update;

        column_access_t(NamedColumn column, bool for_update)
                : col_id(static_cast<int>(column)), update(for_update) {}
    };

    struct cell_access_t {
        int cell_id;
        bool update;

        cell_access_t(int cid, bool for_update)
                : cell_id(cid), update(for_update) {}
    };

    // TransItem key format:
    // |----internal_elem pointer----|--cell id--|I|
    //           48 bits                15 bits   1

    // I: internode bit
    // cell id: valid range 0-32767 (0x7fff)
    // cell id 0 identifies the row item

    class item_key_t {
        typedef uintptr_t type;
        static constexpr unsigned shift = 16u;
        static constexpr type cell_mask = type(0xfffe);
        type key_;

    public:
        item_key_t() : key_() {};
        item_key_t(internal_elem *e, int cell_num) : key_((reinterpret_cast<type>(e) << shift)
                                                          | ((static_cast<type>(cell_num) << 1u) & cell_mask)) {};

        static item_key_t row_item_key(internal_elem *e) {
            return item_key_t(e, 0);
        }

        internal_elem *internal_elem_ptr() const {
            return reinterpret_cast<internal_elem *>(key_ >> shift);
        }

        int cell_num() const {
            return static_cast<int>((key_ & cell_mask) >> 1);
        }

        bool is_row_item() const {
            return (cell_num() == 0);
        }
    };

    static std::vector<cell_access_t>
    column_to_cell_accesses(std::function<int(int)> c_c_map, std::initializer_list<column_access_t> accesses) {
        // pair: {accessed, for update}
        std::vector<std::pair<bool, bool>> all_cells(value_container_type::num_versions, {false, false});
        // the returned list
        std::vector<cell_access_t> cell_accesses;

        for (auto ca : accesses) {
            int cell_id = c_c_map(ca.col_id);
            all_cells[cell_id].first = true;
            all_cells[cell_id].second |= ca.update;
        }

        for (auto it = all_cells.begin(); it != all_cells.end(); ++it) {
            if (it->first)
                cell_accesses.emplace_back(static_cast<int>(it-all_cells.begin()), it->second);
        }
        return cell_accesses;
    }

    typedef std::tuple<bool, bool, uintptr_t, const value_type> sel_return_type;
    typedef std::tuple<bool, bool>                              ins_return_type;
    typedef std::tuple<bool, bool>                              del_return_type;
    uint64_t key_gen_;
    // static __thread typename table_params::threadinfo_type *ti;
    
    tart_index() {
        art = TART();
        static_assert(std::is_base_of<std::string, K>::value, "key must be std::string");
        key_gen_ = 0;
        //static_assert(std::is_base_of<uintptr_t, V>::value, "value must be uintptr_t");
    }
    ~tart_index() {}

    // // TODO
    // template <typename Callback, bool Reverse>
    // bool range_scan(const key_type& begin, const key_type& end, Callback callback,
    //                 std::initializer_list<column_access_t> accesses, bool phantom_protection = true, int limit = -1) {
    //     (void)begin;
    //     (void)end;
    //     (void)callback;
    //     (void)accesses;
    //     (void)phantom_protection;
    //     (void)limit;
    //     return false;
    // }
    //
    // // TODO
    // template <typename Callback, bool Reverse>
    // bool range_scan(const key_type& begin, const key_type& end, Callback callback,
    //                 RowAccess access, bool phantom_protection = true, int limit = -1) {
    //     (void)begin;
    //     (void)end;
    //     (void)callback;
    //     (void)access;
    //     (void)phantom_protection;
    //     (void)limit;
    //     return false;
    // }

    // TODO
    sel_return_type
    select_row(const key_type& key, RowAccess acc) {
    abort:
        return sel_return_type(false, false, 0, value_type());
    }

    // TODO
    sel_return_type
    select_row(const key_type& key, std::initializer_list<column_access_t> accesses) {
    abort:
        return sel_return_type(false, false, 0, value_type());
    }

    // TODO
    sel_return_type
    select_row(uintptr_t rid, RowAccess access) {
    abort:
        return sel_return_type(false, false, 0, value_type());
    }

    // TODO
    sel_return_type
    select_row(uintptr_t rid, std::initializer_list<column_access_t> accesses) {
    abort:
        return sel_return_type(false, false, 0, value_type());
    }

    static void thread_init() {
        // if (ti == nullptr)
        //     ti = threadinfo::make(threadinfo::TI_PROCESS, TThread::id());
        // Transaction::tinfo[TThread::id()].trans_start_callback = []() {
        //     ti->rcu_start();
        // };
        // Transaction::tinfo[TThread::id()].trans_end_callback = []() {
        //     ti->rcu_stop();
        // };
    }

    // DB operations
    sel_return_type select_row(const key_type& k) {
        auto ret = art.lookup(k);
        return sel_return_type(true, true, 0, ret);
    }
    ins_return_type insert_row(const key_type& k, value_type& v, bool overwrite = false) {
        (void)overwrite;
        art.insert(k, v);
        return ins_return_type(true, false);
    }
    void update_row(const key_type& k, value_type& v) {
        art.insert(k, v);
    }
    del_return_type delete_row(const key_type& k) {
        art.erase(k);
        return del_return_type(true, true);
    }

    value_type nontrans_get(const key_type& k) {
        return art.nonTransGet(k.str());
    }
    void nontrans_put(const key_type& k, const value_type& v) {
        art.nonTransPut(k.str(), (art::TVal) &v);
    }

    uint64_t gen_key() {
        return fetch_and_add(&key_gen_, 1);
    }

    bool lock(TransItem& item, Transaction& txn) {
        return art.lock(item, txn);
    }
    bool check(TransItem& item, Transaction& txn) {
        return art.check(item, txn);
    }
    void install(TransItem& item, Transaction& txn) {
        art.install(item, txn);
    }
    void unlock(TransItem& item) {
        art.unlock(item);
    }
private:
    TART art;
};
}
